<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Idiot Kortspill Online</title>
<link rel="icon" href="data:image/png;base64,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">

<style>
:root {
--felt-green: #2a3d2a;
--dark-green: #1a241a;
--wood-brown: #5d3a1a;
--panel-bg: #1f1f1f;
--panel-bg-dark: rgba(0, 0, 0, 0.3);
--text-color: #e0e0e0;
--text-color-dark: #333;
--accent-color: #ffc857;
--red-color: #e57373;
--green-color: #4caf50;
--card-bg: #fdfdfd;
--shadow-light: rgba(0, 0, 0, 0.25);
--shadow-dark: rgba(0, 0, 0, 0.6);
--font-heading: 'Verdana', 'Segoe UI', sans-serif;
--font-body: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
}
*,
*::before,
*::after {
box-sizing: border-box;
margin: 0;
padding: 0;
}
html {
font-size: clamp(14px, 1.5vmin, 18px);
}
body {
background-color: var(--dark-green);
color: var(--text-color);
font-family: var(--font-body);
overflow: hidden;
overscroll-behavior: contain;
height: 100vh;
width: 100vw;
}
h1,
h2,
h3 {
font-family: var(--font-heading);
color: var(--accent-color);
text-align: center;
text-transform: uppercase;
letter-spacing: 1px;
}
h1 {
font-size: 2.5rem;
text-shadow: 2px 2px 4px var(--shadow-dark);
}
h2 {
font-size: 1.8rem;
}
h3 {
font-size: 1.2rem;
color: var(--text-color);
}
button {
font-family: var(--font-heading);
font-size: 1.2rem;
font-weight: 600;
padding: 0.8rem 1.5rem;
background-color: var(--green-color);
color: #ffffff;
border: none;
border-radius: 8px;
cursor: pointer;
transition: background-color 0.3s, transform 0.1s;
box-shadow: 0 4px 6px var(--shadow-light);
text-transform: uppercase;
}
button:hover {
background-color: #5cb85c;
}
button:active {
transform: translateY(2px);
box-shadow: 0 2px 3px var(--shadow-light);
}
button:disabled {
background-color: #616161;
cursor: not-allowed;
}
.container {
display: flex;
flex-direction: column;
width: 100vw;
height: 100vh;
}
.main-content {
flex-grow: 1;
display: flex;
flex-direction: column;
overflow: hidden;
}
.right-panel {
background-color: var(--panel-bg);
color: var(--text-color);
display: flex;
flex-direction: column;
width: 100%;
flex-shrink: 0;
box-shadow: 0 -4px 10px var(--shadow-dark);
max-height: 40%;
z-index: 50;
}
.panel-header {
padding: 0.75rem;
background-color: #2a2a2a;
border-bottom: 1px solid #444;
text-align: center;
}
.panel-body {
padding: 1rem;
overflow-y: auto;
flex-grow: 1;
font-size: 0.9rem;
line-height: 1.6;
}
#log-panel-body p {
padding-bottom: 0.5rem;
margin-bottom: 0.5rem;
border-bottom: 1px solid #444;
word-wrap: break-word;
}
#log-panel-body p:last-child {
border-bottom: none;
}
@media (min-width: 768px) and (min-aspect-ratio: 4/3) {
.container {
flex-direction: row;
}
.right-panel {
border-left: 2px solid #333;
width: 280px;
max-height: 100%;
box-shadow: -4px 0 10px var(--shadow-dark);
}
}
.game-status-overlay {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
color: #ffffff;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
text-align: center;
z-index: 100;
padding: 1rem;
gap: 1.5rem;
}
.game-status-overlay .status-text {
font-family: var(--font-body);
font-size: 1.2rem;
max-width: 500px;
line-height: 1.5;
}
#game-table {
background-color: var(--felt-green);
background-image: radial-gradient(rgba(255, 255, 255, 0.03) 15%,
transparent 15%);
background-size: 20px 20px;
border: 1vmin solid var(--wood-brown);
border-radius: 1.5vmin;
margin: 2vmin;
flex-grow: 1;
display: flex;
flex-direction: column;
justify-content: space-between;
padding: 2vmin;
position: relative;
box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
}
.player-area {
display: flex;
flex-direction: column;
align-items: center;
gap: 1.5vmin;
}
.player-info {
font-family: var(--font-heading);
font-size: 1.1rem;
font-weight: 600;
padding: 0.5rem 1rem;
background-color: var(--panel-bg-dark);
color: #ffffff;
border-radius: 8px;
z-index: 20;
transition: all 0.3s ease-in-out;
}
.player-info.active-turn {
color: var(--accent-color);
box-shadow: 0 0 15px var(--accent-color);
transform: scale(1.1);
}
#play-area {
display: flex;
justify-content: center;
align-items: center;
gap: 2vmin;
padding: 1vmin 0;
}
.cards-area {
display: flex;
justify-content: center;
align-items: flex-end;
gap: 1.2vmin;
min-height: 12vmin;
}
.card {
width: 8.5vmin;
aspect-ratio: 2.5 / 3.5;
border: 1px solid #bbb;
background-color: var(--card-bg);
border-radius: 0.8vmin;
box-shadow: 0.3vmin 0.3vmin 0.6vmin var(--shadow-dark);
font-family: var(--font-heading);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
font-size: 2.5vmin;
font-weight: 600;
position: relative;
flex-shrink: 0;
transition: transform 0.2s ease-out, box-shadow 0.2s;
user-select: none;
color: var(--text-color-dark);
}
.card.face-down {
background-image: radial-gradient(circle at 25% 25%,
#a00 5%,
transparent 5.1%),
radial-gradient(circle at 75% 75%, #a00 5%, transparent 5.1%),
linear-gradient(45deg, #d62828 50%, #900 50%);
background-size: 2vmin 2vmin, 2vmin 2vmin, 100% 100%;
color: transparent;
}
.card-value {
font-size: 1.2em;
}
.card-suit {
font-size: 1em;
line-height: 1;
}
.card-pile {
width: calc(8.5vmin + 1vmin);
aspect-ratio: 2.5 / 3.5;
border: 3px dashed rgba(255, 255, 255, 0.4);
border-radius: 0.8vmin;
display: flex;
justify-content: center;
align-items: center;
font-size: 1rem;
font-family: var(--font-heading);
color: rgba(255, 255, 255, 0.7);
position: relative;
transition: all 0.3s;
}
.card-pile .card {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 1;
}
#discard-pile.pickup-enabled {
cursor: pointer;
border-style: solid;
border-color: var(--accent-color);
box-shadow: 0 0 15px var(--accent-color);
}
#deck-pile-count {
position: absolute;
bottom: 5px;
font-size: 0.9rem;
background-color: var(--panel-bg-dark);
color: #ffffff;
padding: 2px 5px;
border-radius: 5px;
}
.table-cards {
display: flex;
gap: 1.2vmin;
}
.table-card-pile {
position: relative;
width: 8.5vmin;
aspect-ratio: 2.5 / 3.5;
}
.table-card-pile .card {
position: absolute;
top: 0;
left: 0;
}
.table-card-pile .card.face-up {
transform: translate(-0.5vmin, -0.5vmin);
}
.hand-container {
display: flex;
align-items: flex-end;
justify-content: center;
width: 100%;
max-width: 95%;
position: relative;
z-index: 25;
}
.scroll-button {
position: absolute;
top: 50%;
transform: translateY(-50%);
z-index: 30;
background-color: rgba(0, 0, 0, 0.4);
color: white;
border: none;
font-size: 2.5vmin;
padding: 1vmin 1.5vmin;
border-radius: 8px;
cursor: pointer;
opacity: 0.7;
transition: opacity 0.2s, background-color 0.2s;
display: none;
}
#scroll-left {
left: -3vmin;
}
#scroll-right {
right: -3vmin;
}
.scroll-button:hover {
opacity: 1;
background-color: rgba(0, 0, 0, 0.6);
}
.scroll-button:disabled {
opacity: 0.3;
cursor: not-allowed;
}
#player-hand {
display: flex;
flex-wrap: nowrap;
overflow-x: hidden;
padding: 1vmin 0.5vmin 2vmin 0.5vmin;
align-items: flex-end;
min-height: calc(11.9vmin + 3vmin);
width: 100%;
scroll-behavior: smooth;
justify-content: center;
}
#player-hand .card {
cursor: pointer;
margin-left: -2.5vmin;
transition: transform 0.2s ease-out, box-shadow 0.2s, margin-left 0.2s;
}
#player-hand .card:first-child {
margin-left: 0;
}
#player-hand .card:hover {
transform: translateY(-2vmin) scale(1.1);
position: relative;
z-index: 60;
box-shadow: 0.5vmin 0.5vmin 1vmin var(--shadow-dark);
}
</style>
</head>
<body>
<div class="container">
<main class="main-content">
<div id="game-status-overlay" class="game-status-overlay" align="center">
<h1></h1>
<p class="status-text"></p>
<button id="start-game-btn"></button>
</div>
<div id="game-table"></div>
</main>
<aside class="right-panel">
<div class="panel-header">
<h3 id="info-panel-header"></h3>
</div>
<div id="info-panel-body" class="panel-body">
</div>
</aside>
</div>
<script>
const lang = {
gameTitle: "Idiot Kortspill",
playButton: "Spill mot Maskinen",
rulesTitle: "REGLER",
logTitle: "LOGG",
pileLabel: "BUNKE",
playerName: "Spiller",
aiName: "Maskinen",
rulesGoal: "<strong>Mål:</strong> Bli den første til å kvitte deg med alle kortene dine. Den siste spilleren med kort igjen er Idioten!",
rulesGameplay: "<strong>Spill:</strong> Spill et kort med lik eller høyere verdi enn det øverste kortet i bunken. Hvis du ikke kan spille, må du ta opp hele bunken.",
rulesCardOrder: "<strong>Kortrekkefølge:</strong> (Lavest til høyest) 3, 4, 5, 6, 7, 8, 9, J, Q, K, A.",
rulesSpecialCards: "<strong>Spesialkort:</strong>",
rulesCard2: "<strong>2:</strong> Nullstiller bunken. Kan spilles på hva som helst. Neste spiller kan spille hvilket som helst kort.",
rulesCard10: "<strong>10:</strong> Brenner bunken. Bunken fjernes fra spillet, og du får en ny tur. Kan spilles på hva som helst.",
rulesCardFourOfAKind: "<strong>Fire like:</strong> Fire kort med samme verdi på rad brenner også bunken og gir deg en ny tur.",
rulesFinal: "Spill fra hånden, deretter dine synlige kort, og til slutt dine blinde, skjulte kort.",
gameStarted: (playerName) => `Spillet har startet. Det er ${playerName} sin tur!`,
playerTurn: (playerName) => `Det er ${playerName} sin tur.`,
pickedUpPile: (playerName) => `${playerName} tok opp bunken.`,
burnedPile: (playerName) => `${playerName} brente bunken og får en ny tur.`,
playedCard: (playerName, card) => `${playerName} spilte ${card}.`,
fourOfAKind: "Fire like! Bunken er brent.",
pileReset: "Bunken er nullstilt.",
invalidMove: "Ugyldig trekk! Spill et høyere kort eller ta opp bunken.",
playedBlindValid: (card) => `Du spilte ${card} i blinde... og det var et gyldig trekk!`,
playedBlindInvalid: (card) => `Du spilte ${card} i blinde... Uflaks! Du må ta opp bunken.`,
aiPlaysBlindly: (aiName) => `${aiName} spiller i blinde...`,
aiPlaysBlindSuccess: (aiName, card) => `${aiName} spilte ${card} og lyktes!`,
aiPlaysBlindFail: (aiName, card) => `${aiName} spilte ${card} og måtte ta opp bunken!`,
pickupTooltip: "Kan ikke spille. Klikk for å ta opp bunken.",
cardCount: (count) => (count === 1 ? '1 kort' : `${count} kort`),
winTitle: '🎉 DU VANT! 🎉',
winText: (aiName) => `Du ble kvitt alle kortene dine. ${aiName} er Idioten!`,
lossTitle: '😭 DU TAPTE! 😭',
lossText: 'Maskinen ble kvitt alle kortene sine. Du er Idioten! Bedre lykke neste gang.',
playAgainButton: 'Spill Igjen',
renderError: 'En feil oppstod under rendering av spillbrettet:',
criticalError: 'En kritisk feil har oppstått. Vennligst last siden på nytt.',
};
document.addEventListener('DOMContentLoaded', () => {
const PLAYER_NAME = lang.playerName;
const AI_NAME = lang.aiName;
const INITIAL_HAND_CARDS = 3;
const INITIAL_FACE_UP_CARDS = 3;
const INITIAL_FACE_DOWN_CARDS = 3;
const MIN_CARDS_IN_HAND = 3;
const AI_TURN_DELAY = 1200;
const BURN_PILE_DELAY = 600;
const AI_EXTRA_TURN_DELAY = 1000;
const AI_BURN_THRESHOLD = 5;
const LOG_MESSAGE_LIMIT = 20;
const CARD_RANKS = { '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, 'J': 8, 'Q': 9, 'K': 10, 'A': 11, '2': 12, '10': 13 };
const gameTable = document.getElementById('game-table');
const gameStatusOverlay = document.getElementById('game-status-overlay');
const infoPanelHeader = document.getElementById('info-panel-header');
const infoPanelBody = document.getElementById('info-panel-body');
const startGameBtn = document.getElementById('start-game-btn');
let gameState = {};
const getCardValue = (card) => (card ? card.slice(0, -1) : '');
const getCardRank = (card) => card ? CARD_RANKS[getCardValue(card)] || 0 : 0;
const sortCards = (cards) => cards.sort((a, b) => getCardRank(a) - getCardRank(b));
const addLogMessage = (message) => {
gameState.log.push(message);
if (gameState.log.length > LOG_MESSAGE_LIMIT * 2) {
gameState.log = gameState.log.slice(-LOG_MESSAGE_LIMIT);
}
if (gameState.gameInProgress) {
updateLog();
}
};
const initializeUI = () => {
document.title = lang.gameTitle;
document.querySelector('.game-status-overlay h1').textContent = lang.gameTitle;
startGameBtn.textContent = lang.playButton;
infoPanelHeader.textContent = lang.rulesTitle;
infoPanelBody.innerHTML = `
<p>${lang.rulesGoal}</p><br/>
<p>${lang.rulesGameplay}</p><br/>
<p>${lang.rulesCardOrder}</p><br/>
<p>${lang.rulesSpecialCards}</p>
<ul style="padding-left: 20px; margin-top: 0px">
<li>${lang.rulesCard2}</li><br/>
<li>${lang.rulesCard10}</li><br/>
<li>${lang.rulesCardFourOfAKind}</li>
</ul><br/>
<p>${lang.rulesFinal}</p>
`;
gameStatusOverlay.querySelector('.status-text').textContent = '';
};
const updateLog = () => {
infoPanelHeader.textContent = lang.logTitle;
infoPanelBody.innerHTML = '';
const logToShow = gameState.log.slice(-LOG_MESSAGE_LIMIT).reverse();
logToShow.forEach((msg) => {
const p = document.createElement('p');
p.textContent = `> ${msg}`;
infoPanelBody.appendChild(p);
});
infoPanelBody.scrollTop = 0;
};
const showEndScreen = (playerWon) => {
const title = gameStatusOverlay.querySelector('h1');
const text = gameStatusOverlay.querySelector('.status-text');
const button = gameStatusOverlay.querySelector('button');
title.textContent = playerWon ? lang.winTitle : lang.lossTitle;
text.textContent = playerWon ? lang.winText(AI_NAME) : lang.lossText;
button.textContent = lang.playAgainButton;
gameStatusOverlay.style.display = 'flex';
};
const removeCardFromSource = (player, card, sourcePile) => {
const source = gameState.players[player][sourcePile];
const index = source.indexOf(card);
if (index > -1) {
source.splice(index, 1);
return true;
}
console.error(`KRITISK FEIL: Kort ${card} ble ikke funnet i ${player} sin ${sourcePile}.`);
return false;
};
const playerPicksUpPile = (player) => {
if (gameState.discardPile.length === 0) {
switchTurn();
return;
}
const p = gameState.players[player];
p.hand.push(...gameState.discardPile);
sortCards(p.hand);
gameState.discardPile = [];
addLogMessage(lang.pickedUpPile(p.name));
switchTurn();
};
const createNewGame = () => {
const suits = ['H', 'D', 'C', 'S'];
const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
let deck = [];
for (const suit of suits) {
for (const value of values) {
deck.push(value + suit);
}
}
for (let i = deck.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[deck[i], deck[j]] = [deck[j], deck[i]];
}
gameState = {
players: {
[PLAYER_NAME]: {
name: PLAYER_NAME,
hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
},
[AI_NAME]: {
name: AI_NAME,
hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
},
},
deck: deck,
discardPile: [],
log: [],
turn: PLAYER_NAME,
winner: null,
gameInProgress: true,
};
addLogMessage(lang.gameStarted(PLAYER_NAME));
renderGameBoard();
};
const switchTurn = () => {
if (gameState.winner) return;
gameState.turn = gameState.turn === PLAYER_NAME ? AI_NAME : PLAYER_NAME;
addLogMessage(lang.playerTurn(gameState.players[gameState.turn].name));
if (gameState.turn === AI_NAME) {
setTimeout(aiTurn, AI_TURN_DELAY);
} else {
renderGameBoard();
}
};
const drawCards = (player) => {
const p = gameState.players[player];
while (
p.hand.length < MIN_CARDS_IN_HAND &&
gameState.deck.length > 0
) {
p.hand.push(gameState.deck.pop());
}
sortCards(p.hand);
};
const checkWinCondition = (player) => {
const p = gameState.players[player];
if (
p.hand.length === 0 &&
p.faceUp.length === 0 &&
p.faceDown.length === 0
) {
gameState.winner = player;
gameState.gameInProgress = false;
setTimeout(() => showEndScreen(player === PLAYER_NAME), 600);
return true;
}
return false;
};
const checkFourOfAKind = () => {
if (gameState.discardPile.length < 4) return false;
const topFour = gameState.discardPile.slice(-4);
const firstValue = getCardValue(topFour[0]);
return topFour.every(card => getCardValue(card) === firstValue);
};
const burnPile = (player) => {
setTimeout(() => {
gameState.discardPile = [];
addLogMessage(lang.burnedPile(gameState.players[player].name));
drawCards(player);
renderGameBoard();
if (checkWinCondition(player)) return;
if (player === AI_NAME) {
setTimeout(aiTurn, AI_EXTRA_TURN_DELAY);
}
}, BURN_PILE_DELAY);
};
const processMove = (player, card, sourcePile) => {
if (!gameState.gameInProgress) return;
if (!removeCardFromSource(player, card, sourcePile)) return;
gameState.discardPile.push(card);
addLogMessage(lang.playedCard(gameState.players[player].name, card));
renderGameBoard();
if (checkWinCondition(player)) {
return;
}
if (checkFourOfAKind()) {
addLogMessage(lang.fourOfAKind);
burnPile(player);
return;
}
const cardValue = getCardValue(card);
if (cardValue === '10') {
burnPile(player);
return;
}
if (cardValue === '2') {
addLogMessage(lang.pileReset);
}
drawCards(player);
if (checkWinCondition(player)) {
return;
}
switchTurn();
};
const getEffectiveTopCard = () => {
if (gameState.discardPile.length === 0) return null;
for (let i = gameState.discardPile.length - 1; i >= 0; i--) {
if (getCardValue(gameState.discardPile[i]) !== '2') {
return gameState.discardPile[i];
}
}
return null;
};
const checkMoveLegality = (cardToPlay) => {
const cardValue = getCardValue(cardToPlay);
if (cardValue === '2' || cardValue === '10') return true;
if (gameState.discardPile.length === 0) return true;
const actualTopCard = gameState.discardPile[gameState.discardPile.length - 1];
if (getCardValue(actualTopCard) === '2') return true;
const effectiveTopCard = getEffectiveTopCard();
if (!effectiveTopCard) return true;
return getCardRank(cardToPlay) >= getCardRank(effectiveTopCard);
};
const handlePlayerMove = (card, sourcePile) => {
if (gameState.turn !== PLAYER_NAME || !gameState.gameInProgress) return;
if (sourcePile !== 'faceDown' && !checkMoveLegality(card)) {
addLogMessage(lang.invalidMove);
return;
}
if (sourcePile === 'faceDown') {
if (checkMoveLegality(card)) {
addLogMessage(lang.playedBlindValid(card));
processMove(PLAYER_NAME, card, 'faceDown');
} else {
addLogMessage(lang.playedBlindInvalid(card));
if (removeCardFromSource(PLAYER_NAME, card, 'faceDown')) {
gameState.discardPile.push(card);
}
renderGameBoard();
setTimeout(() => playerPicksUpPile(PLAYER_NAME), 800);
}
} else {
processMove(PLAYER_NAME, card, sourcePile);
}
};
const aiTurn = () => {
if (gameState.turn !== AI_NAME || !gameState.gameInProgress) return;
const ai = gameState.players[AI_NAME];
const playableFrom =
ai.hand.length > 0
? 'hand'
: ai.faceUp.length > 0
? 'faceUp'
: 'faceDown';
const cardOptions = ai[playableFrom];
if (playableFrom === 'faceDown') {
const cardToPlay = cardOptions[Math.floor(Math.random() * cardOptions.length)];
addLogMessage(lang.aiPlaysBlindly(AI_NAME));
setTimeout(() => {
if (checkMoveLegality(cardToPlay)) {
addLogMessage(lang.aiPlaysBlindSuccess(AI_NAME, cardToPlay));
processMove(AI_NAME, cardToPlay, 'faceDown');
} else {
addLogMessage(lang.aiPlaysBlindFail(AI_NAME, cardToPlay));
if (removeCardFromSource(AI_NAME, cardToPlay, 'faceDown')) {
gameState.discardPile.push(cardToPlay);
}
renderGameBoard();
setTimeout(() => playerPicksUpPile(AI_NAME), 500);
}
}, 500);
return;
}
const legalMoves = cardOptions.filter(checkMoveLegality);
if (legalMoves.length === 0) {
playerPicksUpPile(AI_NAME);
return;
}
const tens = legalMoves.filter((c) => getCardValue(c) === '10');
if (tens.length > 0 && gameState.discardPile.length >= AI_BURN_THRESHOLD) {
processMove(AI_NAME, tens[0], playableFrom);
return;
}
let normalMoves = legalMoves.filter((c) => !['2', '10'].includes(getCardValue(c)));
if (normalMoves.length > 0) {
processMove(AI_NAME, normalMoves[0], playableFrom);
return;
}
processMove(AI_NAME, legalMoves[0], playableFrom);
};
const renderCard = (cardString, isFaceUp = true, isFaceDownOnTable = false) => {
const card = document.createElement('div');
card.className = 'card';
if (!isFaceUp) {
card.classList.add('face-down');
card.dataset.card = cardString;
return card;
}
const value = getCardValue(cardString);
const suitChar = cardString.slice(-1);
const suitSymbols = { H: '♥', D: '♦', C: '♣', S: '♠' };
card.innerHTML = `<div class="card-value">${value}</div><div class="card-suit">${suitSymbols[suitChar]}</div>`;
card.dataset.card = cardString;
card.style.color = ['H', 'D'].includes(suitChar) ? 'var(--red-color)' : '#333';
if (isFaceDownOnTable) card.classList.add('face-up');
return card;
};
const updateHandScrollButtons = () => {
const playerHand = document.getElementById('player-hand');
if (!playerHand) return;
const scrollLeftBtn = document.getElementById('scroll-left');
const scrollRightBtn = document.getElementById('scroll-right');
const hasOverflow = playerHand.scrollWidth > playerHand.clientWidth;
if (!hasOverflow) {
scrollLeftBtn.style.display = 'none';
scrollRightBtn.style.display = 'none';
return;
}
scrollLeftBtn.style.display = 'block';
scrollRightBtn.style.display = 'block';
scrollLeftBtn.disabled = playerHand.scrollLeft < 1;
scrollRightBtn.disabled = playerHand.scrollLeft + playerHand.clientWidth >= playerHand.scrollWidth - 1;
}
const renderGameBoard = () => {
try {
if (!gameState || !gameState.players) return;
gameTable.innerHTML = '';
const { players, deck, discardPile, turn } = gameState;
const aiArea = document.createElement('div');
aiArea.className = 'player-area opponent-area';
aiArea.innerHTML = `<div class="player-info ${turn === AI_NAME ? 'active-turn' : ''}">${AI_NAME} (${lang.cardCount(players[AI_NAME].hand.length)})</div>`;
const aiTableCards = document.createElement('div');
aiTableCards.className = 'table-cards';
players[AI_NAME].faceDown.forEach((cardStr, i) => {
const pile = document.createElement('div');
pile.className = 'table-card-pile';
pile.appendChild(renderCard(cardStr, false));
if (players[AI_NAME].faceUp[i]) {
pile.appendChild(renderCard(players[AI_NAME].faceUp[i], true, true));
}
aiTableCards.appendChild(pile);
});
aiArea.appendChild(aiTableCards);
gameTable.appendChild(aiArea);
const playArea = document.createElement('div');
playArea.id = 'play-area';
const deckPile = document.createElement('div');
deckPile.className = 'card-pile';
if (deck.length > 0) {
deckPile.appendChild(renderCard(null, false));
deckPile.innerHTML += `<div id="deck-pile-count">${deck.length}</div>`;
}
const discardPileDiv = document.createElement('div');
discardPileDiv.id = 'discard-pile';
discardPileDiv.className = 'card-pile';
if (discardPile.length > 0) {
discardPileDiv.appendChild(renderCard(discardPile[discardPile.length - 1]));
} else {
discardPileDiv.textContent = lang.pileLabel;
}
if (turn === PLAYER_NAME) {
const p = players[PLAYER_NAME];
const currentPlayableCards = p.hand.length > 0 ? p.hand : p.faceUp;
let canPlay = currentPlayableCards.some(checkMoveLegality);
if (p.hand.length === 0 && p.faceUp.length === 0) {
canPlay = true;
}
if (!canPlay && discardPile.length > 0) {
discardPileDiv.classList.add('pickup-enabled');
discardPileDiv.title = lang.pickupTooltip;
discardPileDiv.onclick = () => playerPicksUpPile(PLAYER_NAME);
}
}
playArea.appendChild(deckPile);
playArea.appendChild(discardPileDiv);
gameTable.appendChild(playArea);
const playerArea = document.createElement('div');
playerArea.className = 'player-area your-area';
playerArea.innerHTML = `<div class="player-info ${turn === PLAYER_NAME ? 'active-turn' : ''}">${PLAYER_NAME} (${lang.cardCount(players[PLAYER_NAME].hand.length)})</div>`;
const handContainer = document.createElement('div');
handContainer.className = 'hand-container';
const playerHand = document.createElement('div');
playerHand.id = 'player-hand';
const playerTableCards = document.createElement('div');
playerTableCards.className = 'cards-area table-cards';
const canPlayFromHand = players[PLAYER_NAME].hand.length > 0;
const canPlayFromFaceUp = !canPlayFromHand && players[PLAYER_NAME].faceUp.length > 0;
const canPlayFromFaceDown = !canPlayFromHand && !canPlayFromFaceUp && players[PLAYER_NAME].faceDown.length > 0;
players[PLAYER_NAME].hand.forEach((cardStr) => {
const cardEl = renderCard(cardStr);
if (turn === PLAYER_NAME && canPlayFromHand) {
cardEl.onclick = () => handlePlayerMove(cardEl.dataset.card, 'hand');
}
playerHand.appendChild(cardEl);
});
players[PLAYER_NAME].faceDown.forEach((cardStr, i) => {
const pile = document.createElement('div');
pile.className = 'table-card-pile';
const faceDownCardEl = renderCard(cardStr, false);
pile.appendChild(faceDownCardEl);
if (players[PLAYER_NAME].faceUp[i]) {
const faceUpCardEl = renderCard(players[PLAYER_NAME].faceUp[i], true, true);
pile.appendChild(faceUpCardEl);
if (turn === PLAYER_NAME && canPlayFromFaceUp) {
faceUpCardEl.style.cursor = 'pointer';
faceUpCardEl.onclick = () => handlePlayerMove(faceUpCardEl.dataset.card, 'faceUp');
}
}
if (turn === PLAYER_NAME && canPlayFromFaceDown) {
faceDownCardEl.style.cursor = 'pointer';
faceDownCardEl.onclick = () => handlePlayerMove(faceDownCardEl.dataset.card, 'faceDown');
}
playerTableCards.appendChild(pile);
});
handContainer.appendChild(playerHand);
const scrollLeftBtn = document.createElement('button');
scrollLeftBtn.id = 'scroll-left';
scrollLeftBtn.className = 'scroll-button';
scrollLeftBtn.textContent = '←';
handContainer.appendChild(scrollLeftBtn);
const scrollRightBtn = document.createElement('button');
scrollRightBtn.id = 'scroll-right';
scrollRightBtn.className = 'scroll-button';
scrollRightBtn.textContent = '→';
handContainer.appendChild(scrollRightBtn);
playerArea.appendChild(handContainer);
playerArea.appendChild(playerTableCards);
gameTable.appendChild(playerArea);
updateLog();
setTimeout(updateHandScrollButtons, 50);
} catch (e) {
console.error(lang.renderError, e);
gameTable.innerHTML = `<h1>${lang.criticalError}</h1><p>${e.message}</p>`;
}
};
const startGame = () => {
gameStatusOverlay.style.display = 'none';
infoPanelHeader.textContent = lang.logTitle;
createNewGame();
};
startGameBtn.addEventListener('click', startGame);
gameTable.addEventListener('click', (e) => {
const playerHand = document.getElementById('player-hand');
if (!playerHand || !e.target.matches('.scroll-button')) return;
const scrollAmount = playerHand.clientWidth * 0.8;
if (e.target.id === 'scroll-left') {
playerHand.scrollBy({ left: -scrollAmount });
} else if (e.target.id === 'scroll-right') {
playerHand.scrollBy({ left: scrollAmount });
}
setTimeout(updateHandScrollButtons, 350);
});
initializeUI();
});
</script>
</body>
</html>
