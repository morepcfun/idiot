<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shithead</title>
  <style>
    :root {
      --felt-green: #2a3d2a;
      --dark-green: #1a241a;
      --wood-brown: #5d3a1a;
      --panel-bg: #1f1f1f;
      --panel-bg-dark: rgba(0, 0, 0, 0.3);
      --text-color: #e0e0e0;
      --text-color-dark: #333;
      --accent-color: #ffc857;
      --red-color: #e57373;
      --green-color: #4caf50;
      --card-bg: #fdfdfd;
      --shadow-light: rgba(0, 0, 0, 0.25);
      --shadow-dark: rgba(0, 0, 0, 0.6);
      --font-heading: 'Verdana', 'Segoe UI', sans-serif;
      --font-body: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      font-size: clamp(14px, 1.5vmin, 18px);
    }

    body {
      background-color: var(--dark-green);
      color: var(--text-color);
      font-family: var(--font-body);
      overflow: hidden;
      overscroll-behavior: contain;
      height: 100vh;
      width: 100vw;
    }

    h1,
    h2,
    h3 {
      font-family: var(--font-heading);
      color: var(--accent-color);
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    h1 {
      font-size: 2.5rem;
      text-shadow: 2px 2px 4px var(--shadow-dark);
    }

    h2 {
      font-size: 1.8rem;
    }

    h3 {
      font-size: 1.2rem;
      color: var(--text-color);
    }

    button {
      font-family: var(--font-heading);
      font-size: 1.2rem;
      font-weight: 600;
      padding: 0.8rem 1.5rem;
      background-color: var(--green-color);
      color: #ffffff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
      box-shadow: 0 4px 6px var(--shadow-light);
      text-transform: uppercase;
    }

    button:hover {
      background-color: #5cb85c;
    }

    button:active {
      transform: translateY(2px);
      box-shadow: 0 2px 3px var(--shadow-light);
    }

    button:disabled {
      background-color: #616161;
      cursor: not-allowed;
    }

    .container {
      display: flex;
      flex-direction: column;
      width: 100vw;
      height: 100vh;
    }

    .main-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .right-panel {
      background-color: var(--panel-bg);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      width: 100%;
      flex-shrink: 0;
      box-shadow: 0 -4px 10px var(--shadow-dark);
      max-height: 40%;
      z-index: 50;
    }

    .panel-header {
      padding: 0.75rem;
      background-color: #2a2a2a;
      border-bottom: 1px solid #444;
      text-align: center;
    }

    .panel-body {
      padding: 1rem;
      overflow-y: auto;
      flex-grow: 1;
      font-size: 0.9rem;
      line-height: 1.6;
    }

    #log-panel-body p {
      padding-bottom: 0.5rem;
      margin-bottom: 0.5rem;
      border-bottom: 1px solid #444;
      word-wrap: break-word;
    }

    #log-panel-body p:last-child {
      border-bottom: none;
    }

    /* Desktop layout */
    @media (min-width: 768px) and (min-aspect-ratio: 4/3) {
      .container {
        flex-direction: row;
      }

      .right-panel {
        border-left: 2px solid #333;
        width: 280px;
        max-height: 100%;
        box-shadow: -4px 0 10px var(--shadow-dark);
      }
    }

    .game-status-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      color: #ffffff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 100;
      padding: 1rem;
      gap: 1.5rem;
    }

    .game-status-overlay .status-text {
      font-family: var(--font-body);
      font-size: 1.2rem;
      max-width: 500px;
      line-height: 1.5;
    }

    #game-table {
      background-color: var(--felt-green);
      background-image: radial-gradient(rgba(255, 255, 255, 0.03) 15%,
          transparent 15%);
      background-size: 20px 20px;
      border: 1vmin solid var(--wood-brown);
      border-radius: 1.5vmin;
      margin: 2vmin;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 2vmin;
      position: relative;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .player-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5vmin;
    }

    .player-info {
      font-family: var(--font-heading);
      font-size: 1.1rem;
      font-weight: 600;
      padding: 0.5rem 1rem;
      background-color: var(--panel-bg-dark);
      color: #ffffff;
      border-radius: 8px;
      z-index: 20;
      transition: all 0.3s ease-in-out;
    }

    .player-info.active-turn {
      color: var(--accent-color);
      box-shadow: 0 0 15px var(--accent-color);
      transform: scale(1.1);
    }

    #play-area {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2vmin;
      padding: 1vmin 0;
    }

    .cards-area {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 1.2vmin;
      min-height: 12vmin;
    }

    .card {
      width: 8.5vmin;
      aspect-ratio: 2.5 / 3.5;
      border: 1px solid #bbb;
      background-color: var(--card-bg);
      border-radius: 0.8vmin;
      box-shadow: 0.3vmin 0.3vmin 0.6vmin var(--shadow-dark);
      font-family: var(--font-heading);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 2.5vmin;
      font-weight: 600;
      position: relative;
      flex-shrink: 0;
      transition: transform 0.2s ease-out, box-shadow 0.2s;
      user-select: none;
      color: var(--text-color-dark);
    }

    .card.face-down {
      background-image: radial-gradient(circle at 25% 25%,
          #a00 5%,
          transparent 5.1%),
        radial-gradient(circle at 75% 75%, #a00 5%, transparent 5.1%),
        linear-gradient(45deg, #d62828 50%, #900 50%);
      background-size: 2vmin 2vmin, 2vmin 2vmin, 100% 100%;
      color: transparent;
    }

    .card-value {
      font-size: 1.2em;
    }

    .card-suit {
      font-size: 1em;
      line-height: 1;
    }

    .card-pile {
      width: calc(8.5vmin + 1vmin);
      aspect-ratio: 2.5 / 3.5;
      border: 3px dashed rgba(255, 255, 255, 0.4);
      border-radius: 0.8vmin;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1rem;
      font-family: var(--font-heading);
      color: rgba(255, 255, 255, 0.7);
      position: relative;
      transition: all 0.3s;
    }

    .card-pile .card {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
    }

    #discard-pile.pickup-enabled {
      cursor: pointer;
      border-style: solid;
      border-color: var(--accent-color);
      box-shadow: 0 0 15px var(--accent-color);
    }

    #deck-pile-count {
      position: absolute;
      bottom: 5px;
      font-size: 0.9rem;
      background-color: var(--panel-bg-dark);
      color: #ffffff;
      padding: 2px 5px;
      border-radius: 5px;
    }

    .table-cards {
      display: flex;
      gap: 1.2vmin;
    }

    .table-card-pile {
      position: relative;
      width: 8.5vmin;
      aspect-ratio: 2.5 / 3.5;
    }

    .table-card-pile .card {
      position: absolute;
      top: 0;
      left: 0;
    }

    .table-card-pile .card.face-up {
      transform: translate(-0.5vmin, -0.5vmin);
    }

    .hand-container {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      width: 100%;
      max-width: 95%;
      position: relative;
      z-index: 25;
    }

    .scroll-button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      z-index: 30;
      background-color: rgba(0, 0, 0, 0.4);
      color: white;
      border: none;
      font-size: 2.5vmin;
      padding: 1vmin 1.5vmin;
      border-radius: 8px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s, background-color 0.2s;
      display: none;
    }

    #scroll-left {
      left: -3vmin;
    }

    #scroll-right {
      right: -3vmin;
    }

    .scroll-button:hover {
      opacity: 1;
      background-color: rgba(0, 0, 0, 0.6);
    }

    .scroll-button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    #player-hand {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: hidden;
      padding: 1vmin 0.5vmin 2vmin 0.5vmin;
      align-items: flex-end;
      min-height: calc(11.9vmin + 3vmin);
      width: 100%;
      scroll-behavior: smooth;
      justify-content: center;
    }

    #player-hand .card {
      cursor: pointer;
      margin-left: -2.5vmin;
      transition: transform 0.2s ease-out, box-shadow 0.2s, margin-left 0.2s;
    }

    #player-hand .card:first-child {
      margin-left: 0;
    }

    #player-hand .card:hover {
      transform: translateY(-2vmin) scale(1.1);
      position: relative;
      z-index: 60;
      box-shadow: 0.5vmin 0.5vmin 1vmin var(--shadow-dark);
    }
  </style>
</head>
<body>
  <div class="container">
    <main class="main-content">
      <div id="game-status-overlay" class="game-status-overlay" align="center">
        <h1></h1>
        <p class="status-text"></p>
        <button id="start-game-btn"></button>
      </div>
      <div id="game-table"></div>
    </main>
    <aside class="right-panel">
      <div class="panel-header">
        <h3 id="info-panel-header"></h3>
      </div>
      <div id="info-panel-body" class="panel-body">
      </div>
    </aside>
  </div>
  <script>
    // --- LANGUAGE STRINGS ---
    const lang = {
      gameTitle: "Shithead Card Game",
      playButton: "Play vs. Computer",
      rulesTitle: "RULES",
      logTitle: "LOG",
      pileLabel: "PILE",
      playerName: "Player",
      aiName: "Computer",
      rulesGoal: "<strong>Goal:</strong> Be the first to get rid of all your cards. The last player with cards left is the Shithead!",
      rulesGameplay: "<strong>Gameplay:</strong> Play a card of equal or higher value than the top card on the pile. If you can't play, you must pick up the entire pile.",
      rulesCardOrder: "<strong>Card Order:</strong> (Lowest to highest) 3, 4, 5, 6, 7, 8, 9, J, Q, K, A.",
      rulesSpecialCards: "<strong>Special Cards:</strong>",
      rulesCard2: "<strong>2:</strong> Resets the pile. Can be played on anything. The next player can play any card.",
      rulesCard10: "<strong>10:</strong> Burns the pile. The pile is removed from the game, and you get another turn. Can be played on anything.",
      rulesCardFourOfAKind: "<strong>Four of a Kind:</strong> Four cards of the same value in a row also burn the pile and give you another turn.",
      rulesFinal: "Play from your hand, then your face-up cards, and finally your blind, face-down cards.",
      gameStarted: (playerName) => `The game has started. It's ${playerName}'s turn!`,
      playerTurn: (playerName) => `It's ${playerName}'s turn.`,
      pickedUpPile: (playerName) => `${playerName} picked up the pile.`,
      burnedPile: (playerName) => `${playerName} burned the pile and gets another turn.`,
      playedCard: (playerName, card) => `${playerName} played ${card}.`,
      fourOfAKind: "Four of a kind! The pile is burned.",
      pileReset: "The pile has been reset.",
      invalidMove: "Invalid move! Play a higher card or pick up the pile.",
      playedBlindValid: (card) => `You played ${card} blindly... and it was a valid move!`,
      playedBlindInvalid: (card) => `You played ${card} blindly... Tough luck! You must pick up the pile.`,
      aiPlaysBlindly: (aiName) => `${aiName} is playing blindly...`,
      aiPlaysBlindSuccess: (aiName, card) => `${aiName} played ${card} and succeeded!`,
      aiPlaysBlindFail: (aiName, card) => `${aiName} played ${card} and had to pick up the pile!`,
      pickupTooltip: "Can't play. Click to pick up the pile.",
      cardCount: (count) => (count === 1 ? '1 card' : `${count} cards`),
      winTitle: '🎉 YOU WON! 🎉',
      winText: (aiName) => `You got rid of all your cards. ${aiName} is the Shithead!`,
      lossTitle: '😭 YOU LOST! 😭',
      lossText: "The computer got rid of all its cards. You are the Shithead! Better luck next time.",
      playAgainButton: 'Play Again',
      renderError: 'An error occurred while rendering the game board:',
      criticalError: 'A critical error has occurred. Please reload the page.',
    };

    document.addEventListener('DOMContentLoaded', () => {
      // --- GAME STATE & CONSTANTS ---
      const PLAYER_NAME = lang.playerName;
      const AI_NAME = lang.aiName;

      const INITIAL_HAND_CARDS = 3;
      const INITIAL_FACE_UP_CARDS = 3;
      const INITIAL_FACE_DOWN_CARDS = 3;
      const MIN_CARDS_IN_HAND = 3;
      const AI_TURN_DELAY = 1200;
      const BURN_PILE_DELAY = 600;
      const AI_EXTRA_TURN_DELAY = 1000;
      const AI_BURN_THRESHOLD = 5; // AI will use a 10 if the pile has this many cards or more
      const LOG_MESSAGE_LIMIT = 20;

      // Card ranks where 2 and 10 are special but also have the highest value.
      const CARD_RANKS = { '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, 'J': 8, 'Q': 9, 'K': 10, 'A': 11, '2': 12, '10': 13 };

      const gameTable = document.getElementById('game-table');
      const gameStatusOverlay = document.getElementById('game-status-overlay');
      const infoPanelHeader = document.getElementById('info-panel-header');
      const infoPanelBody = document.getElementById('info-panel-body');
      const startGameBtn = document.getElementById('start-game-btn');

      let gameState = {};

      // --- UTILITY FUNCTIONS ---
      const getCardValue = (card) => (card ? card.slice(0, -1) : '');
      const getCardRank = (card) => (card ? CARD_RANKS[getCardValue(card)] || 0 : 0);
      const sortCards = (cards) => cards.sort((a, b) => getCardRank(a) - getCardRank(b));

      // --- CORE GAME LOGIC ---
      const createNewGame = () => {
        const suits = ['H', 'D', 'C', 'S']; // Hearts, Diamonds, Clubs, Spades
        const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        let deck = [];
        for (const suit of suits) {
          for (const value of values) {
            deck.push(value + suit);
          }
        }

        // Shuffle the deck (Fisher-Yates algorithm)
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }

        gameState = {
          players: {
            [PLAYER_NAME]: {
              name: PLAYER_NAME,
              hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
              faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
              faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
            },
            [AI_NAME]: {
              name: AI_NAME,
              hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
              faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
              faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
            },
          },
          deck: deck,
          discardPile: [],
          log: [],
          turn: PLAYER_NAME,
          winner: null,
          gameInProgress: true,
        };

        addLogMessage(lang.gameStarted(PLAYER_NAME));
        renderGameBoard();
      };

      const processMove = (player, card, sourcePile) => {
        if (!gameState.gameInProgress) return;
        if (!removeCardFromSource(player, card, sourcePile)) return; // Failsafe

        gameState.discardPile.push(card);
        addLogMessage(lang.playedCard(gameState.players[player].name, card));
        renderGameBoard();

        if (checkWinCondition(player)) return;

        if (checkFourOfAKind()) {
          addLogMessage(lang.fourOfAKind);
          burnPile(player);
          return;
        }

        const cardValue = getCardValue(card);
        if (cardValue === '10') {
          burnPile(player);
          return;
        }

        if (cardValue === '2') {
          addLogMessage(lang.pileReset);
        }

        drawCards(player);
        if (checkWinCondition(player)) return;

        switchTurn();
      };

      const handlePlayerMove = (card, sourcePile) => {
        if (gameState.turn !== PLAYER_NAME || !gameState.gameInProgress) return;

        // Playing from hand or face-up requires a legal move
        if (sourcePile !== 'faceDown' && !checkMoveLegality(card)) {
          addLogMessage(lang.invalidMove);
          // Optional: Add a visual cue for an invalid move, like shaking the card
          return;
        }

        // Playing from face-down (blind) has different logic
        if (sourcePile === 'faceDown') {
          if (checkMoveLegality(card)) {
            addLogMessage(lang.playedBlindValid(card));
            processMove(PLAYER_NAME, card, 'faceDown');
          } else {
            addLogMessage(lang.playedBlindInvalid(card));
            if (removeCardFromSource(PLAYER_NAME, card, 'faceDown')) {
              gameState.discardPile.push(card);
            }
            renderGameBoard();
            setTimeout(() => playerPicksUpPile(PLAYER_NAME), 800);
          }
        } else {
          processMove(PLAYER_NAME, card, sourcePile);
        }
      };

      const aiTurn = () => {
        if (gameState.turn !== AI_NAME || !gameState.gameInProgress) return;
        const ai = gameState.players[AI_NAME];
        const playableFrom =
          ai.hand.length > 0
            ? 'hand'
            : ai.faceUp.length > 0
            ? 'faceUp'
            : 'faceDown';
        const cardOptions = ai[playableFrom];

        // Blind play logic
        if (playableFrom === 'faceDown') {
          const cardToPlay = cardOptions[Math.floor(Math.random() * cardOptions.length)];
          addLogMessage(lang.aiPlaysBlindly(AI_NAME));
          setTimeout(() => {
            if (checkMoveLegality(cardToPlay)) {
              addLogMessage(lang.aiPlaysBlindSuccess(AI_NAME, cardToPlay));
              processMove(AI_NAME, cardToPlay, 'faceDown');
            } else {
              addLogMessage(lang.aiPlaysBlindFail(AI_NAME, cardToPlay));
              if (removeCardFromSource(AI_NAME, cardToPlay, 'faceDown')) {
                gameState.discardPile.push(cardToPlay);
              }
              renderGameBoard();
              setTimeout(() => playerPicksUpPile(AI_NAME), 500);
            }
          }, 500);
          return;
        }

        const legalMoves = cardOptions.filter(checkMoveLegality);

        if (legalMoves.length === 0) {
          playerPicksUpPile(AI_NAME);
          return;
        }

        // AI Strategy: Use a 10 to burn a large pile
        const tens = legalMoves.filter((c) => getCardValue(c) === '10');
        if (tens.length > 0 && gameState.discardPile.length >= AI_BURN_THRESHOLD) {
          processMove(AI_NAME, tens[0], playableFrom);
          return;
        }

        // AI Strategy: Play the lowest possible non-special card first
        let normalMoves = legalMoves.filter((c) => !['2', '10'].includes(getCardValue(c)));
        if (normalMoves.length > 0) {
          processMove(AI_NAME, normalMoves[0], playableFrom);
          return;
        }

        // If only special cards are available, play the first one
        processMove(AI_NAME, legalMoves[0], playableFrom);
      };

      const switchTurn = () => {
        if (gameState.winner) return;
        gameState.turn = gameState.turn === PLAYER_NAME ? AI_NAME : PLAYER_NAME;
        addLogMessage(lang.playerTurn(gameState.players[gameState.turn].name));

        if (gameState.turn === AI_NAME) {
          setTimeout(aiTurn, AI_TURN_DELAY);
        } else {
          renderGameBoard(); // Render immediately for the player
        }
      };

      const playerPicksUpPile = (player) => {
        // Can't pick up an empty pile
        if (gameState.discardPile.length === 0) {
          switchTurn();
          return;
        }

        const p = gameState.players[player];
        p.hand.push(...gameState.discardPile);
        sortCards(p.hand);
        gameState.discardPile = [];
        addLogMessage(lang.pickedUpPile(p.name));
        switchTurn(); // Picking up ends your turn
      };

      const burnPile = (player) => {
        setTimeout(() => {
          gameState.discardPile = [];
          addLogMessage(lang.burnedPile(gameState.players[player].name));
          drawCards(player);
          renderGameBoard();

          if (checkWinCondition(player)) return;

          // Burning the pile gives an extra turn
          if (player === AI_NAME) {
            setTimeout(aiTurn, AI_EXTRA_TURN_DELAY);
          }
        }, BURN_PILE_DELAY);
      };

      const drawCards = (player) => {
        const p = gameState.players[player];
        while (
          p.hand.length < MIN_CARDS_IN_HAND &&
          gameState.deck.length > 0
        ) {
          p.hand.push(gameState.deck.pop());
        }
        sortCards(p.hand);
      };

      // --- RULE CHECKING ---
      const checkMoveLegality = (cardToPlay) => {
        const cardValue = getCardValue(cardToPlay);
        // 2s and 10s are always legal plays.
        if (cardValue === '2' || cardValue === '10') return true;

        const effectiveTopCard = getEffectiveTopCard();
        // If the pile is empty or was just reset by a 2, any card is legal.
        if (!effectiveTopCard) return true;

        return getCardRank(cardToPlay) >= getCardRank(effectiveTopCard);
      };

      const getEffectiveTopCard = () => {
        if (gameState.discardPile.length === 0) return null;
        // Look backwards through the pile to find the last non-2 card.
        for (let i = gameState.discardPile.length - 1; i >= 0; i--) {
          if (getCardValue(gameState.discardPile[i]) !== '2') {
            return gameState.discardPile[i];
          }
        }
        return null; // Pile only contains 2s
      };

      const checkFourOfAKind = () => {
        if (gameState.discardPile.length < 4) return false;
        const topFour = gameState.discardPile.slice(-4);
        const firstValue = getCardValue(topFour[0]);
        return topFour.every(card => getCardValue(card) === firstValue);
      };

      const checkWinCondition = (player) => {
        const p = gameState.players[player];
        if (
          p.hand.length === 0 &&
          p.faceUp.length === 0 &&
          p.faceDown.length === 0
        ) {
          gameState.winner = player;
          gameState.gameInProgress = false;
          // Delay showing the end screen to allow the final move to animate/be seen
          setTimeout(() => showEndScreen(player === PLAYER_NAME), 600);
          return true;
        }
        return false;
      };

      const removeCardFromSource = (player, card, sourcePile) => {
        const source = gameState.players[player][sourcePile];
        const index = source.indexOf(card);
        if (index > -1) {
          source.splice(index, 1);
          return true;
        }
        // This should never happen if the game state is consistent.
        console.error(`CRITICAL ERROR: Card ${card} not found in ${player}'s ${sourcePile}.`);
        return false;
      };


      // --- UI & RENDERING ---
      const addLogMessage = (message) => {
        gameState.log.push(message);
        // Trim the log to prevent performance issues with very long games
        if (gameState.log.length > LOG_MESSAGE_LIMIT * 2) {
          gameState.log = gameState.log.slice(-LOG_MESSAGE_LIMIT);
        }
        if (gameState.gameInProgress) {
          updateLog();
        }
      };

      const initializeUI = () => {
        document.title = lang.gameTitle;
        gameStatusOverlay.querySelector('h1').textContent = lang.gameTitle;
        startGameBtn.textContent = lang.playButton;
        infoPanelHeader.textContent = lang.rulesTitle;
        infoPanelBody.innerHTML = `
          <p>${lang.rulesGoal}</p><br/>
          <p>${lang.rulesGameplay}</p><br/>
          <p>${lang.rulesCardOrder}</p><br/>
          <p>${lang.rulesSpecialCards}</p>
          <ul style="padding-left: 20px; margin-top: 0px">
            <li>${lang.rulesCard2}</li><br/>
            <li>${lang.rulesCard10}</li><br/>
            <li>${lang.rulesCardFourOfAKind}</li>
          </ul><br/>
          <p>${lang.rulesFinal}</p>
        `;
        gameStatusOverlay.querySelector('.status-text').textContent = '';
      };

      const updateLog = () => {
        infoPanelHeader.textContent = lang.logTitle;
        infoPanelBody.innerHTML = '';
        const logToShow = gameState.log.slice(-LOG_MESSAGE_LIMIT).reverse();
        logToShow.forEach((msg) => {
          const p = document.createElement('p');
          p.textContent = `> ${msg}`;
          infoPanelBody.appendChild(p);
        });
        // Auto-scroll to the top to show the latest message
        infoPanelBody.scrollTop = 0;
      };

      const showEndScreen = (playerWon) => {
        const title = gameStatusOverlay.querySelector('h1');
        const text = gameStatusOverlay.querySelector('.status-text');
        const button = gameStatusOverlay.querySelector('button');

        title.textContent = playerWon ? lang.winTitle : lang.lossTitle;
        text.textContent = playerWon ? lang.winText(AI_NAME) : lang.lossText;
        button.textContent = lang.playAgainButton;
        gameStatusOverlay.style.display = 'flex';
      };

      const renderCard = (cardString, isFaceUp = true, isFaceDownOnTable = false) => {
        const card = document.createElement('div');
        card.className = 'card';
        if (!isFaceUp) {
          card.classList.add('face-down');
          card.dataset.card = cardString;
          return card;
        }

        const value = getCardValue(cardString);
        const suitChar = cardString.slice(-1);
        const suitSymbols = { H: '♥', D: '♦', C: '♣', S: '♠' };
        card.innerHTML = `<div class="card-value">${value}</div><div class="card-suit">${suitSymbols[suitChar]}</div>`;
        card.dataset.card = cardString;
        card.style.color = ['H', 'D'].includes(suitChar) ? 'var(--red-color)' : '#333';
        if (isFaceDownOnTable) card.classList.add('face-up');
        return card;
      };

      const updateHandScrollButtons = () => {
        const playerHand = document.getElementById('player-hand');
        if (!playerHand) return;
        const scrollLeftBtn = document.getElementById('scroll-left');
        const scrollRightBtn = document.getElementById('scroll-right');

        const hasOverflow = playerHand.scrollWidth > playerHand.clientWidth;
        if (!hasOverflow) {
          scrollLeftBtn.style.display = 'none';
          scrollRightBtn.style.display = 'none';
          return;
        }
        scrollLeftBtn.style.display = 'block';
        scrollRightBtn.style.display = 'block';
        scrollLeftBtn.disabled = playerHand.scrollLeft < 1;
        scrollRightBtn.disabled = playerHand.scrollLeft + playerHand.clientWidth >= playerHand.scrollWidth - 1;
      }

      const renderGameBoard = () => {
        try {
          if (!gameState || !gameState.players) return;
          gameTable.innerHTML = ''; // Clear the board for a fresh render
          const { players, deck, discardPile, turn } = gameState;

          // --- AI Area (Top) ---
          const aiArea = document.createElement('div');
          aiArea.className = 'player-area opponent-area';
          aiArea.innerHTML = `<div class="player-info ${turn === AI_NAME ? 'active-turn' : ''}">${AI_NAME} (${lang.cardCount(players[AI_NAME].hand.length)})</div>`;
          const aiTableCards = document.createElement('div');
          aiTableCards.className = 'table-cards';
          players[AI_NAME].faceDown.forEach((cardStr, i) => {
            const pile = document.createElement('div');
            pile.className = 'table-card-pile';
            pile.appendChild(renderCard(cardStr, false)); // Face-down card
            if (players[AI_NAME].faceUp[i]) {
              pile.appendChild(renderCard(players[AI_NAME].faceUp[i], true, true)); // Face-up card on top
            }
            aiTableCards.appendChild(pile);
          });
          aiArea.appendChild(aiTableCards);
          gameTable.appendChild(aiArea);

          // --- Play Area (Middle) ---
          const playArea = document.createElement('div');
          playArea.id = 'play-area';
          const deckPile = document.createElement('div');
          deckPile.className = 'card-pile';
          if (deck.length > 0) {
            deckPile.appendChild(renderCard(null, false));
            deckPile.innerHTML += `<div id="deck-pile-count">${deck.length}</div>`;
          }
          const discardPileDiv = document.createElement('div');
          discardPileDiv.id = 'discard-pile';
          discardPileDiv.className = 'card-pile';
          if (discardPile.length > 0) {
            discardPileDiv.appendChild(renderCard(discardPile[discardPile.length - 1]));
          } else {
            discardPileDiv.textContent = lang.pileLabel;
          }

          // Enable the pickup functionality if it's the player's turn and they have no legal moves.
          if (turn === PLAYER_NAME) {
            const p = players[PLAYER_NAME];
            const currentPlayableCards = p.hand.length > 0 ? p.hand : p.faceUp;
            let canPlay = currentPlayableCards.some(checkMoveLegality);
            // If hand and face-up are empty, player must play from face-down, which is always an option.
            if (p.hand.length === 0 && p.faceUp.length === 0) {
              canPlay = true;
            }
            if (!canPlay && discardPile.length > 0) {
              discardPileDiv.classList.add('pickup-enabled');
              discardPileDiv.title = lang.pickupTooltip;
              discardPileDiv.onclick = () => playerPicksUpPile(PLAYER_NAME);
            }
          }
          playArea.appendChild(deckPile);
          playArea.appendChild(discardPileDiv);
          gameTable.appendChild(playArea);

          // --- Player Area (Bottom) ---
          const playerArea = document.createElement('div');
          playerArea.className = 'player-area your-area';
          playerArea.innerHTML = `<div class="player-info ${turn === PLAYER_NAME ? 'active-turn' : ''}">${PLAYER_NAME} (${lang.cardCount(players[PLAYER_NAME].hand.length)})</div>`;

          // Hand container with scroll buttons
          const handContainer = document.createElement('div');
          handContainer.className = 'hand-container';
          const playerHand = document.createElement('div');
          playerHand.id = 'player-hand';

          const playerTableCards = document.createElement('div');
          playerTableCards.className = 'cards-area table-cards';
          
          const canPlayFromHand = players[PLAYER_NAME].hand.length > 0;
          const canPlayFromFaceUp = !canPlayFromHand && players[PLAYER_NAME].faceUp.length > 0;
          const canPlayFromFaceDown = !canPlayFromHand && !canPlayFromFaceUp && players[PLAYER_NAME].faceDown.length > 0;

          players[PLAYER_NAME].hand.forEach((cardStr) => {
            const cardEl = renderCard(cardStr);
            if (turn === PLAYER_NAME && canPlayFromHand) {
              cardEl.onclick = () => handlePlayerMove(cardEl.dataset.card, 'hand');
            }
            playerHand.appendChild(cardEl);
          });

          players[PLAYER_NAME].faceDown.forEach((cardStr, i) => {
            const pile = document.createElement('div');
            pile.className = 'table-card-pile';
            const faceDownCardEl = renderCard(cardStr, false);
            pile.appendChild(faceDownCardEl);

            if (players[PLAYER_NAME].faceUp[i]) {
              const faceUpCardEl = renderCard(players[PLAYER_NAME].faceUp[i], true, true);
              pile.appendChild(faceUpCardEl);
              if (turn === PLAYER_NAME && canPlayFromFaceUp) {
                faceUpCardEl.style.cursor = 'pointer';
                faceUpCardEl.onclick = () => handlePlayerMove(faceUpCardEl.dataset.card, 'faceUp');
              }
            }

            if (turn === PLAYER_NAME && canPlayFromFaceDown) {
              faceDownCardEl.style.cursor = 'pointer';
              faceDownCardEl.onclick = () => handlePlayerMove(faceDownCardEl.dataset.card, 'faceDown');
            }
            playerTableCards.appendChild(pile);
          });

          handContainer.appendChild(playerHand);

          // Create and append scroll buttons
          const scrollLeftBtn = document.createElement('button');
          scrollLeftBtn.id = 'scroll-left';
          scrollLeftBtn.className = 'scroll-button';
          scrollLeftBtn.textContent = '←';
          handContainer.appendChild(scrollLeftBtn);

          const scrollRightBtn = document.createElement('button');
          scrollRightBtn.id = 'scroll-right';
          scrollRightBtn.className = 'scroll-button';
          scrollRightBtn.textContent = '→';
          handContainer.appendChild(scrollRightBtn);

          playerArea.appendChild(handContainer);
          playerArea.appendChild(playerTableCards);
          gameTable.appendChild(playerArea);

          updateLog();
          // Delay to allow the DOM to update before checking for overflow
          setTimeout(updateHandScrollButtons, 50);
        } catch (e) {
          console.error(lang.renderError, e);
          gameTable.innerHTML = `<h1>${lang.criticalError}</h1><p>${e.message}</p>`;
        }
      };

      // --- EVENT LISTENERS & INITIALIZATION ---
      const startGame = () => {
        gameStatusOverlay.style.display = 'none';
        infoPanelHeader.textContent = lang.logTitle;
        createNewGame();
      };

      startGameBtn.addEventListener('click', startGame);

      // Event delegation for hand scroll buttons
      gameTable.addEventListener('click', (e) => {
        const playerHand = document.getElementById('player-hand');
        if (!playerHand || !e.target.matches('.scroll-button')) return;

        const scrollAmount = playerHand.clientWidth * 0.8;
        if (e.target.id === 'scroll-left') {
          playerHand.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
        } else if (e.target.id === 'scroll-right') {
          playerHand.scrollBy({ left: scrollAmount, behavior: 'smooth' });
        }
        // Update button state after scroll animation finishes
        setTimeout(updateHandScrollButtons, 350);
      });

      initializeUI();
    });
  </script>
</body>
</html>