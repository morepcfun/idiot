<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Shithead</title>
<meta name="author" content="Johnny Heggelund">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
:root {
--felt-green: #0a632b;
--dark-green: #07471f;
--wood-brown: #5d3a1a;
--panel-bg: #f0f0f0;
--panel-bg-dark: rgba(0, 0, 0, 0.2);
--text-color: #333;
--text-color-light: #ffffff;
--accent-color: #ffc857;
--red-color: #d62828;
--green-color: #4caf50;
--card-bg: #ffffff;
--shadow-light: rgba(0, 0, 0, 0.15);
--shadow-dark: rgba(0, 0, 0, 0.4);
--font-heading: 'Verdana', 'Segoe UI', sans-serif;
--font-body: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
}
*,
*::before,
*::after {
box-sizing: border-box;
margin: 0;
padding: 0;
}
html {
font-size: clamp(14px, 1.5vmin, 18px);
}
body {
background-color: var(--dark-green);
color: var(--text-color);
font-family: var(--font-body);
overflow: hidden;
overscroll-behavior: contain;
height: 100vh;
width: 100vw;
}
h1,
h2,
h3 {
font-family: var(--font-heading);
color: var(--accent-color);
text-align: center;
text-transform: uppercase;
letter-spacing: 1px;
}
h1 {
font-size: 2.5rem;
text-shadow: 2px 2px 4px var(--shadow-dark);
}
h2 {
font-size: 1.8rem;
}
h3 {
font-size: 1.2rem;
color: var(--text-color);
}
button {
font-family: var(--font-heading);
font-size: 1.2rem;
font-weight: 600;
padding: 0.8rem 1.5rem;
background-color: var(--green-color);
color: var(--text-color-light);
border: none;
border-radius: 8px;
cursor: pointer;
transition: background-color 0.3s, transform 0.1s;
box-shadow: 0 4px 6px var(--shadow-light);
text-transform: uppercase;
}
button:hover {
background-color: #5cb85c;
}
button:active {
transform: translateY(2px);
box-shadow: 0 2px 3px var(--shadow-light);
}
button:disabled {
background-color: #9e9e9e;
cursor: not-allowed;
}
.container {
display: flex;
flex-direction: column;
width: 100vw;
height: 100vh;
}
.main-content {
flex-grow: 1;
display: flex;
flex-direction: column;
overflow: hidden;
}
.right-panel {
background-color: var(--panel-bg);
display: flex;
flex-direction: column;
width: 100%;
flex-shrink: 0;
box-shadow: 0 -4px 10px var(--shadow-dark);
max-height: 40%;
}
.panel-header {
padding: 0.75rem;
background-color: #e0e0e0;
border-bottom: 1px solid #ccc;
text-align: center;
}
.panel-body {
padding: 1rem;
overflow-y: auto;
flex-grow: 1;
font-size: 0.9rem;
line-height: 1.6;
}
#log-panel-body p {
padding-bottom: 0.5rem;
margin-bottom: 0.5rem;
border-bottom: 1px solid #ddd;
word-wrap: break-word;
}
#log-panel-body p:last-child {
border-bottom: none;
}
@media (min-width: 768px) and (min-aspect-ratio: 4/3) {
.container {
flex-direction: row;
}
.right-panel {
border-left: 2px solid #ddd;
width: 280px;
max-height: 100%;
box-shadow: -4px 0 10px var(--shadow-dark);
}
}
.game-status-overlay {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0, 0, 0, 0.2);
backdrop-filter: blur(0px);
color: var(--text-color-light);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
text-align: center;
z-index: 100;
padding: 1rem;
gap: 1.5rem;
}
.game-status-overlay .status-text {
font-family: var(--font-body);
font-size: 1.2rem;
max-width: 500px;
line-height: 1.5;
}
#game-table {
background-color: var(--felt-green);
background-image: radial-gradient(rgba(255, 255, 255, 0.05) 15%,
transparent 15%);
background-size: 20px 20px;
border: 1vmin solid var(--wood-brown);
border-radius: 1.5vmin;
margin: 2vmin;
flex-grow: 1;
display: flex;
flex-direction: column;
justify-content: space-between;
padding: 2vmin;
position: relative;
box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
}
.player-area {
display: flex;
flex-direction: column;
align-items: center;
gap: 1.5vmin;
}
.player-info {
font-family: var(--font-heading);
font-size: 1.1rem;
font-weight: 600;
padding: 0.5rem 1rem;
background-color: var(--panel-bg-dark);
color: var(--text-color-light);
border-radius: 8px;
z-index: 20;
transition: all 0.3s ease-in-out;
}
.player-info.active-turn {
color: var(--accent-color);
box-shadow: 0 0 15px var(--accent-color);
transform: scale(1.1);
}
#play-area {
display: flex;
justify-content: center;
align-items: center;
gap: 2vmin;
padding: 1vmin 0;
}
.cards-area {
display: flex;
justify-content: center;
align-items: flex-end;
gap: 1.2vmin;
min-height: 12vmin;
}
.card {
width: 8.5vmin;
aspect-ratio: 2.5 / 3.5;
border: 1px solid #bbb;
background-color: var(--card-bg);
border-radius: 0.8vmin;
box-shadow: 0.3vmin 0.3vmin 0.6vmin var(--shadow-dark);
font-family: var(--font-heading);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
font-size: 2.5vmin;
font-weight: 600;
position: relative;
flex-shrink: 0;
transition: transform 0.2s ease-out, box-shadow 0.2s;
user-select: none;
}
.card.face-down {
background-image: radial-gradient(circle at 25% 25%,
#a00 5%,
transparent 5.1%),
radial-gradient(circle at 75% 75%, #a00 5%, transparent 5.1%),
linear-gradient(45deg, var(--red-color) 50%, #900 50%);
background-size: 2vmin 2vmin, 2vmin 2vmin, 100% 100%;
color: transparent;
}
.card-value {
font-size: 1.2em;
}
.card-suit {
font-size: 1em;
line-height: 1;
}
.card-pile {
width: calc(8.5vmin + 1vmin);
aspect-ratio: 2.5 / 3.5;
border: 3px dashed rgba(255, 255, 255, 0.4);
border-radius: 0.8vmin;
display: flex;
justify-content: center;
align-items: center;
font-size: 1rem;
font-family: var(--font-heading);
color: rgba(255, 255, 255, 0.7);
position: relative;
transition: all 0.3s;
}
.card-pile .card {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 1;
}
#discard-pile.pickup-enabled {
cursor: pointer;
border-style: solid;
border-color: var(--accent-color);
box-shadow: 0 0 15px var(--accent-color);
}
#deck-pile-count {
position: absolute;
bottom: 5px;
font-size: 0.9rem;
background-color: var(--panel-bg-dark);
color: var(--text-color-light);
padding: 2px 5px;
border-radius: 5px;
}
.table-cards {
display: flex;
gap: 1.2vmin;
}
.table-card-pile {
position: relative;
width: 8.5vmin;
aspect-ratio: 2.5 / 3.5;
}
.table-card-pile .card {
position: absolute;
top: 0;
left: 0;
}
.table-card-pile .card.face-up {
transform: translate(-0.5vmin, -0.5vmin);
}
.hand-container {
display: flex;
align-items: flex-end;
justify-content: center;
width: 100%;
max-width: 95%;
position: relative;
}
.scroll-button {
position: absolute;
top: 50%;
transform: translateY(-50%);
z-index: 30;
background-color: rgba(0, 0, 0, 0.4);
color: white;
border: none;
font-size: 2.5vmin;
padding: 1vmin 1.5vmin;
border-radius: 8px;
cursor: pointer;
opacity: 0.7;
transition: opacity 0.2s, background-color 0.2s;
display: none;
}
#scroll-left {
left: -3vmin;
}
#scroll-right {
right: -3vmin;
}
.scroll-button:hover {
opacity: 1;
background-color: rgba(0, 0, 0, 0.6);
}
.scroll-button:disabled {
opacity: 0.3;
cursor: not-allowed;
}
#player-hand {
display: flex;
flex-wrap: nowrap;
overflow-x: hidden;
padding: 1vmin 0.5vmin 2vmin 0.5vmin;
align-items: flex-end;
min-height: calc(11.9vmin + 3vmin);
width: 100%;
scroll-behavior: smooth;
justify-content: center;
}
#player-hand .card {
cursor: pointer;
margin-left: -2.5vmin;
transition: transform 0.2s ease-out, box-shadow 0.2s, margin-left 0.2s;
}
#player-hand .card:first-child {
margin-left: 0;
}
#player-hand .card:hover {
transform: translateY(-2vmin) scale(1.1);
position: relative;
z-index: 10;
box-shadow: 0.5vmin 0.5vmin 1vmin var(--shadow-dark);
}
</style>
</head>
<body>
<div class="container">
<main class="main-content">
<div id="game-status-overlay" class="game-status-overlay" align="center">
<h1>Shithead Card Game</h1>
<p class="status-text"></p>
<button id="start-game-btn">Play Against Computer</button>
</div>
<div id="game-table"></div>
</main>
<aside class="right-panel">
<div class="panel-header">
<h3 id="info-panel-header">RULES</h3>
</div>
<div id="info-panel-body" class="panel-body">
</div>
</aside>
</div>
<script>
// STATS-FETCHER-START
fetch('https://www.chromebooker.com/stats/visitors.php', {
method: 'POST',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify({ page: window.location.href })
});
// STATS-FETCHER-END
const languageStrings = {
en: {
gameTitle: 'Shithead Card Game',
playButton: 'Play Against Computer',
rulesTitle: 'RULES',
logTitle: 'LOG',
pileLabel: 'PILE',
playerName: 'Player',
aiName: 'Computer',
rulesGoal: '<strong>Goal:</strong> Be the first to get rid of all your cards. The last player with cards is the Shithead!',
rulesGameplay: '<strong>Gameplay:</strong> Play a card with equal or higher value than the top card of the pile. If you can\'t play, you must pick up the whole pile.',
rulesCardOrder: '<strong>Card order:</strong> (Lowest to Highest) 3, 4, 5, 6, 7, 8, 9, J, Q, K, A.',
rulesSpecialCards: '<strong>Special cards:</strong>',
rulesCard2: '<strong>2:</strong> Resets the pile. Can be played on anything. Next player can play any card.',
rulesCard10: '<strong>10:</strong> Burns the pile. The pile is removed, and you get another turn. Can be played on anything.',
rulesCardFourOfAKind: '<strong>Four of a kind:</strong> Four cards of the same value in a row also burn the pile and give you another turn.',
rulesFinal: 'Play from your hand, then face-up cards, and finally blind face-down cards.',
gameStarted: (playerName) => `Game started. ${playerName}'s turn!`,
playerTurn: (playerName) => `It's ${playerName}'s turn.`,
pickedUpPile: (playerName) => `${playerName} picked up the pile.`,
burnedPile: (playerName) => `${playerName} burned the pile and gets another turn.`,
playedCard: (playerName, card) => `${playerName} played ${card}.`,
fourOfAKind: 'Four of a kind! The pile is burned.',
pileReset: 'The pile is reset.',
invalidMove: 'Invalid move! Play a higher card or pick up the pile.',
playedBlindValid: (card) => `You played ${card} blindly... and it was a valid move!`,
playedBlindInvalid: (card) => `You played ${card} blindly... Unlucky! You have to pick up the pile.`,
aiPlaysBlindly: (aiName) => `${aiName} plays blindly...`,
aiPlaysBlindSuccess: (aiName, card) => `${aiName} played ${card} and succeeded!`,
aiPlaysBlindFail: (aiName, card) => `${aiName} played ${card} and had to pick up!`,
pickupTooltip: 'Cannot play. Click to pick up the pile.',
cardCount: (count) => (count === 1 ? '1 card' : `${count} cards`),
winTitle: '🎉 YOU WON! 🎉',
winText: (aiName) => `You got rid of all your cards. The ${aiName} is the Shithead!`,
lossTitle: '😭 YOU LOST! 😭',
lossText: 'The computer got rid of all cards. You are the Shithead! Better luck next time.',
playAgainButton: 'Play Again',
renderError: 'An error occurred while rendering the game board:',
criticalError: 'A critical error has occurred. Please reload the page.',
}
};
document.addEventListener('DOMContentLoaded', () => {
const currentLang = 'en';
const lang = languageStrings[currentLang];
const PLAYER_NAME = lang.playerName;
const AI_NAME = lang.aiName;
const INITIAL_HAND_CARDS = 3;
const INITIAL_FACE_UP_CARDS = 3;
const INITIAL_FACE_DOWN_CARDS = 3;
const MIN_CARDS_IN_HAND = 3;
const AI_TURN_DELAY = 1200;
const BURN_PILE_DELAY = 600;
const AI_EXTRA_TURN_DELAY = 1000;
const AI_BURN_THRESHOLD = 5;
const LOG_MESSAGE_LIMIT = 20;
const CARD_RANKS = {
'3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, 'J': 8, 'Q': 9, 'K': 10, 'A': 11, '2': 12, '10': 13,
};
const gameTable = document.getElementById('game-table');
const gameStatusOverlay = document.getElementById('game-status-overlay');
const infoPanelHeader = document.getElementById('info-panel-header');
const infoPanelBody = document.getElementById('info-panel-body');
const startGameBtn = document.getElementById('start-game-btn');
let gameState = {};
const getCardValue = (card) => (card ? card.slice(0, -1) : '');
const getCardRank = (card) =>
card ? CARD_RANKS[getCardValue(card)] || 0 : 0;
const sortCards = (cards) =>
cards.sort((a, b) => getCardRank(a) - getCardRank(b));
const addLogMessage = (message) => {
gameState.log.push(message);
if (gameState.log.length > LOG_MESSAGE_LIMIT * 2) {
gameState.log = gameState.log.slice(-LOG_MESSAGE_LIMIT);
}
if (gameState.gameInProgress) {
updateLog();
}
};
const initializeUI = () => {
document.querySelector('.game-status-overlay h1').textContent = lang.gameTitle;
startGameBtn.textContent = lang.playButton;
infoPanelHeader.textContent = lang.rulesTitle;
infoPanelBody.innerHTML = `
<p>${lang.rulesGoal}</p><br/>
<p>${lang.rulesGameplay}</p><br/>
<p>${lang.rulesCardOrder}</p><br/>
<p>${lang.rulesSpecialCards}</p>
<ul style="padding-left: 20px; margin-top: 0px">
<li>${lang.rulesCard2}</li><br/>
<li>${lang.rulesCard10}</li><br/>
<li>${lang.rulesCardFourOfAKind}</li>
</ul><br/>
<p>${lang.rulesFinal}</p>
`;
gameStatusOverlay.querySelector('.status-text').textContent = '';
};
const updateLog = () => {
infoPanelHeader.textContent = lang.logTitle;
infoPanelBody.innerHTML = '';
const logToShow = gameState.log.slice(-LOG_MESSAGE_LIMIT).reverse();
logToShow.forEach((msg) => {
const p = document.createElement('p');
p.textContent = `> ${msg}`;
infoPanelBody.appendChild(p);
});
infoPanelBody.scrollTop = 0;
};
const showEndScreen = (playerWon) => {
const title = gameStatusOverlay.querySelector('h1');
const text = gameStatusOverlay.querySelector('.status-text');
const button = gameStatusOverlay.querySelector('button');
title.textContent = playerWon ? lang.winTitle : lang.lossTitle;
text.textContent = playerWon ? lang.winText(AI_NAME) : lang.lossText;
button.textContent = lang.playAgainButton;
gameStatusOverlay.style.display = 'flex';
};
const removeCardFromSource = (player, card, sourcePile) => {
const source = gameState.players[player][sourcePile];
const index = source.indexOf(card);
if (index > -1) {
source.splice(index, 1);
return true;
}
console.error(
`CRITICAL ERROR: Card ${card} was not found in ${player}'s ${sourcePile}.`
);
return false;
};
const playerPicksUpPile = (player) => {
if (gameState.discardPile.length === 0) {
switchTurn();
return;
}
const p = gameState.players[player];
p.hand.push(...gameState.discardPile);
sortCards(p.hand);
gameState.discardPile = [];
addLogMessage(lang.pickedUpPile(p.name));
switchTurn();
};
const createNewGame = () => {
const suits = ['H', 'D', 'C', 'S'];
const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
let deck = [];
for (const suit of suits) {
for (const value of values) {
deck.push(value + suit);
}
}
for (let i = deck.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[deck[i], deck[j]] = [deck[j], deck[i]];
}
gameState = {
players: {
[PLAYER_NAME]: {
name: PLAYER_NAME,
hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
},
[AI_NAME]: {
name: AI_NAME,
hand: sortCards(deck.splice(0, INITIAL_HAND_CARDS)),
faceUp: sortCards(deck.splice(0, INITIAL_FACE_UP_CARDS)),
faceDown: deck.splice(0, INITIAL_FACE_DOWN_CARDS),
},
},
deck: deck,
discardPile: [],
log: [lang.gameStarted(PLAYER_NAME)],
turn: PLAYER_NAME,
winner: null,
gameInProgress: true,
};
renderGameBoard();
};
const switchTurn = () => {
if (gameState.winner) return;
gameState.turn = gameState.turn === PLAYER_NAME ? AI_NAME : PLAYER_NAME;
addLogMessage(lang.playerTurn(gameState.players[gameState.turn].name));
if (gameState.turn === AI_NAME) {
setTimeout(aiTurn, AI_TURN_DELAY);
} else {
renderGameBoard();
}
};
const drawCards = (player) => {
const p = gameState.players[player];
while (
p.hand.length < MIN_CARDS_IN_HAND &&
gameState.deck.length > 0
) {
p.hand.push(gameState.deck.pop());
}
sortCards(p.hand);
};
const checkWinCondition = (player) => {
const p = gameState.players[player];
if (
p.hand.length === 0 &&
p.faceUp.length === 0 &&
p.faceDown.length === 0
) {
gameState.winner = player;
gameState.gameInProgress = false;
setTimeout(() => showEndScreen(player === PLAYER_NAME), 600);
return true;
}
return false;
};
const checkFourOfAKind = () => {
if (gameState.discardPile.length < 4) return false;
const topFour = gameState.discardPile.slice(-4);
const firstValue = getCardValue(topFour[0]);
return topFour.every(card => getCardValue(card) === firstValue);
};
const burnPile = (player) => {
setTimeout(() => {
gameState.discardPile = [];
addLogMessage(lang.burnedPile(gameState.players[player].name));
drawCards(player);
renderGameBoard();
if (checkWinCondition(player)) return;
if (player === AI_NAME) {
setTimeout(aiTurn, AI_EXTRA_TURN_DELAY);
}
}, BURN_PILE_DELAY);
};
const processMove = (player, card, sourcePile) => {
if (!gameState.gameInProgress) return;
if (!removeCardFromSource(player, card, sourcePile)) return;
gameState.discardPile.push(card);
addLogMessage(lang.playedCard(gameState.players[player].name, card));
renderGameBoard();
if (checkWinCondition(player)) {
return;
}
if (checkFourOfAKind()) {
addLogMessage(lang.fourOfAKind);
burnPile(player);
return;
}
const cardValue = getCardValue(card);
if (cardValue === '10') {
burnPile(player);
return;
}
if (cardValue === '2') {
addLogMessage(lang.pileReset);
}
drawCards(player);
if (checkWinCondition(player)) {
return;
}
switchTurn();
};
const getEffectiveTopCard = () => {
if (gameState.discardPile.length === 0) return null;
for (let i = gameState.discardPile.length - 1; i >= 0; i--) {
if (getCardValue(gameState.discardPile[i]) !== '2') {
return gameState.discardPile[i];
}
}
return null;
};
const checkMoveLegality = (cardToPlay) => {
const cardValue = getCardValue(cardToPlay);
if (cardValue === '2' || cardValue === '10') return true;
if (gameState.discardPile.length === 0) return true;
const actualTopCard = gameState.discardPile[gameState.discardPile.length - 1];
if (getCardValue(actualTopCard) === '2') return true;
const effectiveTopCard = getEffectiveTopCard();
if (!effectiveTopCard) return true;
return getCardRank(cardToPlay) >= getCardRank(effectiveTopCard);
};
const handlePlayerMove = (card, sourcePile) => {
if (gameState.turn !== PLAYER_NAME || !gameState.gameInProgress) return;
if (sourcePile !== 'faceDown' && !checkMoveLegality(card)) {
addLogMessage(lang.invalidMove);
return;
}
if (sourcePile === 'faceDown') {
if (checkMoveLegality(card)) {
addLogMessage(lang.playedBlindValid(card));
processMove(PLAYER_NAME, card, 'faceDown');
} else {
addLogMessage(lang.playedBlindInvalid(card));
if (removeCardFromSource(PLAYER_NAME, card, 'faceDown')) {
gameState.discardPile.push(card);
}
renderGameBoard();
setTimeout(() => playerPicksUpPile(PLAYER_NAME), 800);
}
} else {
processMove(PLAYER_NAME, card, sourcePile);
}
};
const aiTurn = () => {
if (gameState.turn !== AI_NAME || !gameState.gameInProgress) return;
const ai = gameState.players[AI_NAME];
const playableFrom =
ai.hand.length > 0
? 'hand'
: ai.faceUp.length > 0
? 'faceUp'
: 'faceDown';
const cardOptions = ai[playableFrom];
if (playableFrom === 'faceDown') {
const cardToPlay =
cardOptions[Math.floor(Math.random() * cardOptions.length)];
addLogMessage(lang.aiPlaysBlindly(AI_NAME));
setTimeout(() => {
if (checkMoveLegality(cardToPlay)) {
addLogMessage(lang.aiPlaysBlindSuccess(AI_NAME, cardToPlay));
processMove(AI_NAME, cardToPlay, 'faceDown');
} else {
addLogMessage(lang.aiPlaysBlindFail(AI_NAME, cardToPlay));
if (removeCardFromSource(AI_NAME, cardToPlay, 'faceDown')) {
gameState.discardPile.push(cardToPlay);
}
renderGameBoard();
setTimeout(() => playerPicksUpPile(AI_NAME), 500);
}
}, 500);
return;
}
const legalMoves = cardOptions.filter(checkMoveLegality);
if (legalMoves.length === 0) {
playerPicksUpPile(AI_NAME);
return;
}
const tens = legalMoves.filter((c) => getCardValue(c) === '10');
if (
tens.length > 0 &&
gameState.discardPile.length >= AI_BURN_THRESHOLD
) {
processMove(AI_NAME, tens[0], playableFrom);
return;
}
let normalMoves = legalMoves.filter(
(c) => !['2', '10'].includes(getCardValue(c))
);
if (normalMoves.length > 0) {
processMove(AI_NAME, normalMoves[0], playableFrom);
return;
}
processMove(AI_NAME, legalMoves[0], playableFrom);
};
const renderCard = (cardString, isFaceUp = true, isFaceDownOnTable = false) => {
const card = document.createElement('div');
card.className = 'card';
if (!isFaceUp) {
card.classList.add('face-down');
card.dataset.card = cardString;
return card;
}
const value = getCardValue(cardString);
const suitChar = cardString.slice(-1);
const suitSymbols = { H: '♥', D: '♦', C: '♣', S: '♠' };
card.innerHTML = `<div class="card-value">${value}</div><div class="card-suit">${suitSymbols[suitChar]}</div>`;
card.dataset.card = cardString;
card.style.color = ['H', 'D'].includes(suitChar)
? 'var(--red-color)'
: '#333';
if (isFaceDownOnTable) card.classList.add('face-up');
return card;
};
const updateHandScrollButtons = () => {
const playerHand = document.getElementById('player-hand');
if (!playerHand) return;
const scrollLeftBtn = document.getElementById('scroll-left');
const scrollRightBtn = document.getElementById('scroll-right');
const hasOverflow = playerHand.scrollWidth > playerHand.clientWidth;
if (!hasOverflow) {
scrollLeftBtn.style.display = 'none';
scrollRightBtn.style.display = 'none';
return;
}
scrollLeftBtn.style.display = 'block';
scrollRightBtn.style.display = 'block';
scrollLeftBtn.disabled = playerHand.scrollLeft < 1;
scrollRightBtn.disabled = playerHand.scrollLeft + playerHand.clientWidth >= playerHand.scrollWidth - 1;
}
const renderGameBoard = () => {
try {
if (!gameState || !gameState.players) return;
gameTable.innerHTML = '';
const { players, deck, discardPile, turn } = gameState;
const aiArea = document.createElement('div');
aiArea.className = 'player-area opponent-area';
aiArea.innerHTML = `<div class="player-info ${turn === AI_NAME ? 'active-turn' : ''
}">${AI_NAME} (${lang.cardCount(players[AI_NAME].hand.length)})</div>`;
const aiTableCards = document.createElement('div');
aiTableCards.className = 'table-cards';
players[AI_NAME].faceDown.forEach((cardStr, i) => {
const pile = document.createElement('div');
pile.className = 'table-card-pile';
pile.appendChild(renderCard(cardStr, false));
if (players[AI_NAME].faceUp[i]) {
pile.appendChild(
renderCard(players[AI_NAME].faceUp[i], true, true)
);
}
aiTableCards.appendChild(pile);
});
aiArea.appendChild(aiTableCards);
gameTable.appendChild(aiArea);
const playArea = document.createElement('div');
playArea.id = 'play-area';
const deckPile = document.createElement('div');
deckPile.className = 'card-pile';
if (deck.length > 0) {
deckPile.appendChild(renderCard(null, false));
deckPile.innerHTML += `<div id="deck-pile-count">${deck.length}</div>`;
}
const discardPileDiv = document.createElement('div');
discardPileDiv.id = 'discard-pile';
discardPileDiv.className = 'card-pile';
if (discardPile.length > 0) {
discardPileDiv.appendChild(renderCard(discardPile[discardPile.length - 1]));
} else {
discardPileDiv.textContent = lang.pileLabel;
}
if (turn === PLAYER_NAME) {
const p = players[PLAYER_NAME];
const currentPlayableCards = p.hand.length > 0 ? p.hand : p.faceUp;
let canPlay = currentPlayableCards.some(checkMoveLegality);
if (p.hand.length === 0 && p.faceUp.length === 0) {
canPlay = true;
}
if (!canPlay && discardPile.length > 0) {
discardPileDiv.classList.add('pickup-enabled');
discardPileDiv.title = lang.pickupTooltip;
discardPileDiv.onclick = () => playerPicksUpPile(PLAYER_NAME);
}
}
playArea.appendChild(deckPile);
playArea.appendChild(discardPileDiv);
gameTable.appendChild(playArea);
const playerArea = document.createElement('div');
playerArea.className = 'player-area your-area';
playerArea.innerHTML = `<div class="player-info ${turn === PLAYER_NAME ? 'active-turn' : ''
}">${PLAYER_NAME} (${lang.cardCount(players[PLAYER_NAME].hand.length)})</div>`;
const handContainer = document.createElement('div');
handContainer.className = 'hand-container';
const playerHand = document.createElement('div');
playerHand.id = 'player-hand';
const playerTableCards = document.createElement('div');
playerTableCards.className = 'cards-area table-cards';
const canPlayFromHand = players[PLAYER_NAME].hand.length > 0;
const canPlayFromFaceUp =
!canPlayFromHand && players[PLAYER_NAME].faceUp.length > 0;
const canPlayFromFaceDown =
!canPlayFromHand &&
!canPlayFromFaceUp &&
players[PLAYER_NAME].faceDown.length > 0;
players[PLAYER_NAME].hand.forEach((cardStr) => {
const cardEl = renderCard(cardStr);
if (turn === PLAYER_NAME && canPlayFromHand) {
cardEl.onclick = () =>
handlePlayerMove(cardEl.dataset.card, 'hand');
}
playerHand.appendChild(cardEl);
});
players[PLAYER_NAME].faceDown.forEach((cardStr, i) => {
const pile = document.createElement('div');
pile.className = 'table-card-pile';
const faceDownCardEl = renderCard(cardStr, false);
pile.appendChild(faceDownCardEl);
if (players[PLAYER_NAME].faceUp[i]) {
const faceUpCardEl = renderCard(players[PLAYER_NAME].faceUp[i], true, true);
pile.appendChild(faceUpCardEl);
if (turn === PLAYER_NAME && canPlayFromFaceUp) {
faceUpCardEl.style.cursor = 'pointer';
faceUpCardEl.onclick = () =>
handlePlayerMove(faceUpCardEl.dataset.card, 'faceUp');
}
}
if (turn === PLAYER_NAME && canPlayFromFaceDown) {
faceDownCardEl.style.cursor = 'pointer';
faceDownCardEl.onclick = () =>
handlePlayerMove(faceDownCardEl.dataset.card, 'faceDown');
}
playerTableCards.appendChild(pile);
});
handContainer.appendChild(playerHand);
const scrollLeftBtn = document.createElement('button');
scrollLeftBtn.id = 'scroll-left';
scrollLeftBtn.className = 'scroll-button';
scrollLeftBtn.textContent = '←';
handContainer.appendChild(scrollLeftBtn);
const scrollRightBtn = document.createElement('button');
scrollRightBtn.id = 'scroll-right';
scrollRightBtn.className = 'scroll-button';
scrollRightBtn.textContent = '→';
handContainer.appendChild(scrollRightBtn);
playerArea.appendChild(handContainer);
playerArea.appendChild(playerTableCards);
gameTable.appendChild(playerArea);
updateLog();
setTimeout(updateHandScrollButtons, 50);
} catch (e) {
console.error(lang.renderError, e);
gameTable.innerHTML = `<h1>${lang.criticalError}</h1><p>${e.message}</p>`;
}
};
const startGame = () => {
gameStatusOverlay.style.display = 'none';
infoPanelHeader.textContent = lang.logTitle;
createNewGame();
};
startGameBtn.addEventListener('click', startGame);
gameTable.addEventListener('click', (e) => {
const playerHand = document.getElementById('player-hand');
if (!playerHand || !e.target.matches('.scroll-button')) return;
const scrollAmount = playerHand.clientWidth * 0.8;
if (e.target.id === 'scroll-left') {
playerHand.scrollBy({ left: -scrollAmount });
} else if (e.target.id === 'scroll-right') {
playerHand.scrollBy({ left: scrollAmount });
}
setTimeout(updateHandScrollButtons, 350);
});
initializeUI();
});
</script>
</body>
</html>